#!/bin/bash -e

trap 'echo "error: $(basename $0): line $LINENO"; exit 1' ERR

if test $# -lt 3 ; then
  echo "USAGE: `basename $0` INPUT_BITCODE -o OUTPUT_BITCODE"
  exit 1
fi

inputIR=$1
afterLoopMetadata="afterLoopMetadata.bc"
intermediateResult="baseline_with_parallel_plan.bc"
intermediateResult_unoptimized="parallelized_unoptimized.bc"
outputIR=$3

# step 0: add loop id to all loops
noelle-meta-loop-embed ${inputIR} -o ${afterLoopMetadata}

# step 1: run parallelization planner
gino-planner ${afterLoopMetadata} -o ${intermediateResult} ${@:4}

# step 2: include function prototypes needed by parallelization techniques
clang -c -emit-llvm NOELLE_APIs.c
llvm-link NOELLE_APIs.bc ${intermediateResult} -o code_with_prototypes.bc
noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc

# step 3: run loop parallelization on bitcode with parallel plan
gino-loops code_to_parallelize.bc -o ${intermediateResult_unoptimized} ${@:4}

# step 4: cleaning the metadata that are now disaligned with the code
noelle-meta-clean ${intermediateResult_unoptimized} -o ${intermediateResult_unoptimized}
clang -O3 -c -emit-llvm ${intermediateResult_unoptimized} -o ${outputIR}

# step 6: link with the runtime
llvm-link ${outputIR} Parallelizer_utils.bc -o ${outputIR}

# step 7: conventional optimizations
clang -O3 -c -emit-llvm ${outputIR} -o ${outputIR}
